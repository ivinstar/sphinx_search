

authors = ['zhuravlev', 'unknown', 'zearks']

Article.create!({author: authors.sample,
	             title: 'Cухой антипаттерн',
	             content: 'Паттерн существует в нескольких «обличьях». Суть его от этого меняется не сильно, опасность его применения существует в любом из них. 
Первый, классический вид — это некий долгоживущий объект, который принимающий другой объект по интерфейсу, собственно стратегию, через сеттер, при некотором изменении состояния. 
Второй вид, вырожденный вариант первого — стратегия принимается один раз, на все время жизни объекта. Т.е. для одного сценария используется одна стратегия, для другого другая.
Третий вид, это исполняемый метод, либо статический, либо в короткоживущем объекте, принимающий в качестве входного параметра стратегию по интерфейсу. У «банды четырёх» этот вид назван как «Template method».
Четвертый вид — интерфейсный, ака UI-ный. Иногда называется как паттерн «шаблон», иногда как «контейнер». На примере веб-разработки — представляет из себя некий, кусок разметки, содержащий в себе плейсхолдер (а то и не один), куда во время исполнения отрендерится изменяемая, имеющая несколько разных реализаций, часть разметки. Параллельно разметке, в JavaScript коде также живут параллельные вью-модели или контроллеры, в зависимости от архитектуры, принятой в приложении, организованные по второму виду.

Общие черты этих всех случаев: 
1)некоторая неизменяемая часть ака имеющая одну реализацию, далее, я буду называть ее контейнером
2)изменяемая часть, она же стратегия
3)место использования, создающее/вызывающее контейнер, определяющее какую стратегию контейнер должен использовать, далее буду называть это сценарием.

Поначалу, когда компонент, с использованием этого паттерна только реализовывался в проекте, он не казался таким уж плохим. Применен он был, когда было нужно создать две одинаковые страницы(опять же, на примере веб-разработки), которые лишь немного отличаются контентом в середине. Даже наоборот, разработчик порадовался, насколько красиво и изящно получилось реализовать принцип DRY, т.е. полностью избежать дублирования кода. Именно такие эпитеты я слышал о компоненте, когда он был только-только создан. Тот самый, который стал попаболью всего проекта несколькими месяцами позже.
И раз уж я начал теоретизировать, зайду чуть дальше — именно попытки реализовать принцип DRY, через паттерн strategy, собственно как и через наследование, приводят к тьме. Когда в угоду DRY, сам того не замечая, разработчик жертвует принципом SRP, первым и главным постулатом из SOLID. К слову, DRY не является частью SOLID, и при конфликте, надо жертвовать именно им, ибо он не благоприятствует созданию устойчивого кода в отличие от, собственно, SOLID. Как оказалось — скорее даже наоборот. Переиспользование кода должно быть приятным бонусом тех или иных дизайн-решений, а не целью принятия оных.'})

Article.create!({author: authors.sample,
	             title: 'Зачем нужны паттерны проектирования или «Что такое MVC?»',
	             content: 'Самое главное во всех фреймворках это то, что все они диктуют правила создания приложения. Если ты никогда не использовал никакого фреймворка в своих приложениях, то либо они слишком малы и ты не сталкивался с проблемой нарастающего хаоса в коде, либо просто не пришло твоё время :) И в конце концов приложение созданное по правилам фреймворка однозначно обретёт правильную форму. А разве не этого все мы хотим? Новичок в программировании начав изучение какого-либо фреймворка автоматически начинает правильно мыслить, тем самым перенимая опыт предыдущих поколений и открывая себе более гладкую дорогу вперёд. В любом случае единственная возможность создания больших, расширяемых и модульных приложений это использование фреймворка.

Итак начнём…

MVC «Модель-представление-поведение» === «Модель-представление-контроллер».

А теперь закрой глаза и представь себе работу своего приложения. Представил?… так вот, попробуй условно разбить этот процесс на три абстрактые логические части: 

Собери все методы своего приложения которые занимаются обработкой всех визуальных компонентов, методы которые имеют знания о визуальном элементе, которые занимаются перемещением их по экрану и т.д. Мысленно объедини их в одну часть программы, это и будет (Представление).

Далее. Собери все методы своего приложения которые занимаются логикой приложения, методы которые имеют знания о том, что и как делать. Модель поведения компонентов приложения. Мысленно объедини их в одну часть программы, это и будет (Модель). 

Третья, но не менее важная часть, это те методы в которых реализовано само поведение модели. Так называемый «Контроллер». Вообщем это любые методы, которые вызываются к примеру событием проигрыша игры, допустим: function onLoseLevel(e:SomeEvent):void. В данном случае этот метод является поведением модели вашего приложения в случае проигрыша. Как только вы проиграли уровень вызывается конкретный метод, которые реализует поведение приложения в конкретном случае. Так вот, собери все методы, реализующие поведение в одну кучу 
это и будет третья логическая часть концепции MVC, (Контроллер).'})


Article.create!({author: authors.sample,
	             title: 'GRASP паттерны проектирования',
	             content: 'GRASP (General Responsibility Assignment Software Patterns) — шаблоны проектирования, используемые для решения общих задач по назначению обязанностей классам и объектам.

Известно девять GRAPS шаблонов, изначально описанных в книге Крейга Лармана «Применение UML и шаблонов проектирования». В отличие от привычных читателю паттернов из Банды Четырех, GRAPS паттерны не имеют выраженной структуры, четкой области применения и конкретной решаемой проблемы, а лишь представляют собой обобщенные подходы/рекомендации/принципы, используемые при проектировании дизайна системы.

Рассмотрим характеристики основных GRASP шаблонов.

Применение шаблона информационный эксперт повышает связность модулей и не противоречит свойству инкапсуляции.

Контроллер (Controller)

Контроллер отвечает за обработку входных системных событий, делегируя обязанности по их обработке компетентным классам. В общем случае, контроллер реализует один или несколько вариантов использования.

Известно понятие внешнего контроллера (Front Controller), который представляет всю систему в целом (агрегирует весь функционал системы в одном классе).

Примером контроллера является класс Administrator, реализующий вариант использования системы администратором из отдела комплектации рейсов.


Использование контроллеров позволяет отделить логику от представления, тем самым повышая возможность повторного использования кода.'})